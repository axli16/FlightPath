## 2024-05-24 - [YOLO Post-Processing Loop Optimization]
**Learning:** In standard YOLO implementations (OpenCV/Darknet), the class confidence score is defined as `Objectness * ClassProbability`. Therefore, the final confidence for any class can never exceed the initial `Objectness` score (index 4). By adding a check `if (objectness <= threshold) continue;` at the start of the loop, we can skip the inner loop iterating over 80+ classes for the vast majority of "background" anchors.
**Action:** Always check for hierarchical probability relationships in nested loops. If an upper bound (like Objectness) is already below a threshold, skip the detailed probability calculations. This yielded a ~53x speedup in the post-processing loop benchmark.

## 2024-05-25 - [OpenCV Zero-Copy Optimizations]
**Learning:** `cv::Mat::clone()` creates a deep copy of the underlying image buffer, which is an expensive operation (allocation + memory copy), especially in hot loops or frame processing queues. Since `cv::Mat` uses reference counting, sub-matrices (ROI extraction via `frame(roi)`) or direct assignments (`processFrame = frame`) share the same underlying data buffer without copying. In pipelines where the original frames remain valid (e.g., synchronous batch processing in `ObjectDetector::detectBatch` or passing views to `cv::dnn::blobFromImages`), or where lifecycle ownership is correctly managed (e.g., `VideoProcessor::cropToCenter` returning a view when caller's buffer is fresh), redundant `.clone()` calls should be aggressively removed.
**Action:** Always scrutinize `.clone()` calls in OpenCV pipelines. Prefer zero-copy operations (ROI extraction, assignment) unless the data must be explicitly isolated from modifications or the source buffer will be overwritten/destroyed before the view is consumed.

## 2024-05-26 - [Thread-Safe Queue Optimizations & OpenCV State Overhead]
**Learning:** In C++ multi-threaded frame processing queues (like `DroppingSafeQueue`), passing objects containing large vectors (e.g., `std::vector<Detection>`, `std::vector<Path>`) without move semantics causes expensive deep copies on every `push` and `pop`. Adding an rvalue `push(T&&)` and using `std::move(queue_.front())` eliminates this overhead. Additionally, repeatedly setting OpenCV DNN backend/target preferences (e.g., `network_.setPreferableBackend`) inside a hot per-frame loop incurs unnecessary state-checking overhead; these should only be set once during model initialization.
**Action:** Always implement move semantics (`std::move`) in custom thread-safe queues handling large data structures to prevent deep copies. Audit hot loops for redundant state configuration calls that can be hoisted to initialization.
